// @ts-check
export const QuartoInstances = new Map()

const UvicornLogPattern = /(?<ip>[\d.]+):(?<port>\d+)\s+-\s+"(?<method>[A-Z]+)\s+(?<path>[^\s]+)\s+(?<protocol>HTTP\/\d+\.\d+)"\s+(?<status>\d+)/;
const PatternLogRender = /(Starting render of `.*`)|(Copying `.*` to `.*`)|(Rendered `.*`)./
const PatternRenderFailed = /Failed to render `.*`./
const PatternRenderDefered = /Dispatching render of `.*` from changes in `.*`./
const PatternLogWebSocket = /^\('(?<ip>[\d.]+)', (?<port>\d+)\) - "WebSocket (?<path>[^"]+)" \[(?<detail>([^\]]+))\]$/

export const LIVE_VERBOSE = true
export const LIVE_QUARTO_VERBOSE = true
export const LIVE_SERVER_VERBOSE = true

/** @typedef {Map<string, string[]>}  */
const EXT_TO_ICON = new Map()
EXT_TO_ICON.set("py", ["bi-filetype-py", "text-yellow"])
EXT_TO_ICON.set("qmd", ["bi-filetype-md", "text-teal"])
EXT_TO_ICON.set("html", ["bi-filetype-html", "text-orange"])
EXT_TO_ICON.set("js", ["bi-filetype-js", "text-green"])
EXT_TO_ICON.set("scss", ["bi-filetype-scss", "text-pink"])
EXT_TO_ICON.set("yaml", ["bi-filetype-yml", "text-yellow"])
EXT_TO_ICON.set("pdf", ["bi-filetype-pdf", "text-red"])

/** @typedef {import("./overlay.js").Overlay} Overlay */


/** Warning! Generated by GPT using JSON Schemas.
 *
 * @typedef {Object} LogItem
 * @property {number} [created] - Created timestamp (must be greater than 0).
 * @property {string} filename - Filename.
 * @property {string} funcName - Function name.
 * @property {string} levelname - Logging level name.
 * @property {number} levelno - Logging level number.
 * @property {number} lineno - Line number in the file.
 * @property {string} module - Module name.
 * @property {string} msg - Log message.
 * @property {string} name - Logger name.
 * @property {string} pathname - Full path to the file.
 * @property {string} threadName - Thread name.
 * @property {string} created_time
 */


/** Warning! Generated by GPT using JSON Schemas.
 *
 * @typedef {Object} QuartoRender
 * @property {string} time - Time at which the log was generated.
 * @property {string} target_url_path - URL to the render target.
 * @property {number} timestamp - Timestamp (must be greater than 0).
 * @property {"client"|"lifespan"} item_from - Source of the render request.
 * @property {"defered"|"direct"|"static"} kind - Kind of render (default: "direct").
 * @property {string} origin - Origin of the render request.
 * @property {string} target - Target of the render operation.
 * @property {number} status_code - Status code of the render operation.
 * @property {string[]} command - Command executed during the render.
 * @property {string[]} stderr - Standard error output from the render.
 * @property {string[]} stdout - Standard output from the render.
 */





// ------------------------------------------------------------------------- //
// Helpers

/** Create the listener timer.
 *
 * @param {WebSocket} ws -
 */
function createWebsocketTimer(ws) {
  /**
   * @memberof live
   * @typedef {object} WebsocketTimerState
   * @property {number|undefined} id
   * @property {() => Promise<void>} start
   * @property {() => void} stop
   *
   */

  /** @type WebsocketTimerState */
  const state = {
    start: async () => {
      LIVE_VERBOSE && console.log("Waiting...")
      const id = setInterval(() => {
        LIVE_VERBOSE && console.log("Waiting...")
        ws.send("null")
      }, 1000)
      // @ts-ignore
      state.id = id
    },
    id: undefined,
    stop: () => {
      clearInterval(state.id)
    }
  }

  ws.addEventListener("open", state.start)
  ws.addEventListener("close", state.stop)
  return state
}

/** Options for ``handlePathlike``
 *
 * @typedef {object} PathlikeOptions - Additional options for output.
 *
 * @property {string|null} wrapperTag - Tag for the output `HTMLElement`.
 * @property {Array<string>|null} textClasses - Additional classes for the text. Text is usually ``pathlike``.
 * @property {string|null} textTag - ``HTML`` tag to wrap ``pathlike`` in. By default it is ``text``.
 * @property {Array<string>|null} iconClasses - Additional classes to apply to the icon.
 */


/** Get and style bootstrap icon for a path.
 *
 * @param {string} pathlike -
 * @param {Partial<PathlikeOptions>} options -
 *
 * @returns a stylized ``HTML`` element with ``pathlike`` and an appropriate
 *   bootstrap file icon.
 */
function handlePathlike(pathlike, { wrapperTag, textClasses, textTag, iconClasses }) {

  if (!pathlike) throw Error("Missing required argument `pathlike`.")

  const text = document.createElement(textTag || "text")
  textClasses && text.classList.add(...textClasses)
  text.innerText = pathlike

  const ext = pathlike.split(".").pop()
  if (!ext) throw Error(`Could not determine extension of \`${pathlike}\`.`)

  const icon = document.createElement("i")
  icon.classList.add("bi", ... (EXT_TO_ICON.get(ext) || ["bi-file"]), ...(iconClasses || ["px-3"]))

  const output = document.createElement(wrapperTag || 'p')
  if (wrapperTag === 'a') {
    // @ts-ignore
    output.href = pathlike
  }

  output.appendChild(icon)
  output.appendChild(text)

  return output
}

/**
 * @param {object} options - Request body.
 * @param {Array<string|object> | null} [options.items] - Items to render.
 */
async function requestRender({ items }) {
  LIVE_QUARTO_VERBOSE && console.log("Requesting quarto render.")

  const res = await fetch("/api/dev/quarto/render", {
    body: JSON.stringify({ items: items || [window.location.pathname] }),
    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', },
    method: "POST",
  })
  return res
}


/**
 * @param {object} filter - Filtering parameters.
 */
async function requestRenderHistory(filter) {
  LIVE_QUARTO_VERBOSE && console.log("Requesting quarto render history.")

  const res = await fetch("/api/dev/quarto", {
    body: JSON.stringify(filter),
    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', },
    method: "POST",
  })
  return res
}

/**
 * @param {object} filter - Filtering parameters.
 */
async function requestLast(filter) {
  LIVE_QUARTO_VERBOSE && console.log("Requesting last item rendered.")

  const res = await fetch(
    "/api/dev/quarto/last",
    {
      method: "POST",
      body: JSON.stringify(filter),
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      }
    }
  )

  return res
}


// ------------------------------------------------------------------------- //
// LIVER SERVER LOGS

/** Turn a websocket log item into a table row for display.
 *
 * Uvicorn server logs get special highlighting to make them easier to read.
 * Time should not be added unless it does not equal the time in the previous
 * row.
 *
 * The parameters are derived from ``Array.map``.
 * These parameters are used to inspect the previous row to omit repeated
 * information (and eventually repeated logs).
 *
 * @param {number} index - The index of the current item.
 * @param {LogItem} item - The current item.
 * @param {Array<LogItem>} array - All items.
 */
function hydrateServerLogItem(item, index, array) {

  const itemPrevious = index > 0 ? array[index - 1] : null

  const elem = document.createElement("tr")
  const itemTime = document.createElement("td")
  const itemName = document.createElement("td")
  const itemMsg = document.createElement("td")
  const itemLevel = document.createElement("td")

  if (!itemPrevious || item.created_time != itemPrevious.created_time) {
    itemTime.textContent = '[' + item.created_time + ']'
  }
  itemLevel.textContent = item.levelname
  itemName.textContent = item.name + ":" + item.lineno

  if (UvicornLogPattern.test(item.msg)) {
    // @ts-ignore
    const { ip, port, method, path, protocol, status } = item.msg.match(UvicornLogPattern)?.groups

    const uvicornIp = document.createElement("span")
    const uvicornPort = document.createElement("span")
    const uvicornMethod = document.createElement("span")
    const uvicornPath = document.createElement("span")
    const uvicornStatus = document.createElement("span")
    const uvicornProtocol = document.createElement("span")

    uvicornIp.textContent = ip
    uvicornPort.textContent = ":" + port
    uvicornMethod.textContent = " " + method
    uvicornPath.textContent = " " + path
    uvicornStatus.textContent = " " + status
    uvicornProtocol.textContent = " " + protocol

    uvicornIp.classList.add("uvicorn-ip")
    uvicornPort.classList.add("uvicorn-port")
    uvicornMethod.classList.add("uvicorn-method")
    uvicornPath.classList.add("uvicorn-path")
    uvicornStatus.classList.add("uvicorn-status")
    uvicornProtocol.classList.add("uvicorn-protocol")

    itemMsg.appendChild(uvicornIp)
    itemMsg.appendChild(uvicornPort)
    itemMsg.appendChild(uvicornMethod)
    itemMsg.appendChild(uvicornPath)
    itemMsg.appendChild(uvicornStatus)
    itemMsg.appendChild(uvicornProtocol)
  }
  else if (PatternLogWebSocket.test(item.msg)) {
    // @ts-ignore
    const { ip, port, detail, path } = item.msg.match(PatternLogWebSocket)?.groups

    const uvicornIp = document.createElement("span")
    const uvicornPort = document.createElement("span")
    const uvicornMethod = document.createElement("span")
    const uvicornPath = document.createElement("span")
    // const uvicornStatus = document.createElement("span")
    const uvicornProtocol = document.createElement("span")

    uvicornIp.textContent = ip
    uvicornPort.textContent = ":" + port
    uvicornMethod.textContent = " " + detail.toUpperCase()
    uvicornPath.textContent = " " + path
    uvicornProtocol.textContent = " WEBSOCKET"

    uvicornIp.classList.add("uvicorn-ip")
    uvicornPort.classList.add("uvicorn-port")
    uvicornMethod.classList.add("uvicorn-method")
    uvicornPath.classList.add("uvicorn-path")
    // uvicornStatus.classList.add("uvicorn-status")
    uvicornProtocol.classList.add("uvicorn-protocol")

    itemMsg.appendChild(uvicornIp)
    itemMsg.appendChild(uvicornPort)
    itemMsg.appendChild(uvicornMethod)
    itemMsg.appendChild(uvicornPath)
    // itemMsg.appendChild(uvicornStatus)
    itemMsg.appendChild(uvicornProtocol)

  }
  else {
    itemMsg.textContent = item.msg
  }

  if (PatternLogRender.test(item.msg)) {
    itemMsg.style.color = "var(--bs-green)"
  }
  else if (PatternRenderDefered.test(item.msg)) {
    itemMsg.style.color = "var(--bs-blue)"
  }
  else if (PatternRenderFailed.test(item.msg)) {
    itemMsg.style.color = "var(--bs-red)";
  }
  else if (item.msg.startsWith("connection")) {
    itemMsg.style.color = "var(--bs-gray-600)"
  }

  itemTime.classList.add("terminal-row-time")
  itemLevel.classList.add("terminal-row-level")
  itemMsg.classList.add("terminal-row-msg")
  itemName.classList.add("terminal-row-name", "text-dark")
  itemLevel.classList.add(item.levelname.toLowerCase())

  elem.classList.add("terminal-row")
  elem.appendChild(itemTime)
  elem.appendChild(itemLevel)
  elem.appendChild(itemMsg)
  elem.appendChild(itemName)

  const state = { highlight: false }
  const highlightClasses = ["border", "border-1", "border-yellow"]

  elem.addEventListener("click", () => {
    state.highlight ? elem.classList.remove(...highlightClasses) : elem.classList.add(...highlightClasses)
    state.highlight = !state.highlight
  })

  return elem
}



/** Add reactivity to ``ServerLog``. Generates new rows when logs are pushed
 * to the websocket.
 *
 * @param {object} options - Server log configuration.
 * @param {HTMLElement} options.logTable - The table containing all of the
 *   server logs.
 * @param {HTMLElement} options.logContainer - A parent element of the table. This
 *   makes it such that when new logs are pushed the bottom of the page is
 *   scrolled to. In the initial version, this was the tab content div.
 *
 */
export function Server({
  logTable,
  logContainer,
}) {
  if (!logTable) throw Error("`logTable` is required.")
  if (!logContainer) throw Error("`logContainer` is required.")

  const logTableBody = logTable.querySelector("tbody")
  if (!logTableBody) throw Error("Could not find table body.")
  const ws = new WebSocket("/api/dev/log")

  ws.addEventListener(
    "message",
    (event) => {
      const data = JSON.parse(event.data)
      if (!data) return

      data.items.map(
        /**
         * @param {LogItem} item -
         * @param {number} index -
         * @param {Array<LogItem>} array -
         */
        (item, index, array) => {
          const elem = hydrateServerLogItem(item, index, array)
          logTableBody.appendChild(elem)
          logContainer.scrollTop = logContainer.scrollHeight
        }

      )
    },
  )

  createWebsocketTimer(ws)

  if (LIVE_SERVER_VERBOSE) {
    ws.addEventListener("close", (event) => console.log(event))
    ws.addEventListener("open", () => console.log("Websocket connection opened for logs."))
  }

  return { ws }
}

// ------------------------------------------------------------------------- //
// Quarto


/** Create overlay content for a quarto render.
 *
 * All errors will be highlighted in red and the overlay content will be colorized to red.
 * Successful renders of ``qmd`` documents will be colorized to blue.
 * Successful updates of static assets will be colorized in teal.
 *
 * @param {QuartoRender} item - an item pushed from ``quarto`` logs websocket.
 *
 */
function hydrateQuartoOverlayItem(item) {

  const contentItem = document.createElement("div")
  contentItem.classList.add("overlay-content-item", "hidden")
  contentItem.dataset.key = String(item.timestamp)
  contentItem.dataset.colorizeColor = item.status_code ? "danger" : (
    item.kind === "static" ?
      "primary" : "teal")

  const terminal = document.createElement('code')
  terminal.classList.add('terminal', 'p-3')
  contentItem.appendChild(terminal)

  const colorClass = !item.status_code ? "text-light" : "text-danger"

  const timestamp = document.createElement("span")
  timestamp.textContent = "Timestamp: " + item.timestamp
  timestamp.classList.add("terminal-row", "quarto-exit-code", colorClass)

  const command = document.createElement("span")
  command.textContent = "Command: " + item.command
  command.classList.add("terminal-row", "quarto-command", colorClass)

  const origin = document.createElement("span")
  origin.textContent = "Origin: " + item.origin
  origin.classList.add("terminal-row", "quarto-origin", colorClass)

  const target = document.createElement("span")
  target.textContent = "Target: " + item.target
  target.classList.add("terminal-row", "quarto-target", colorClass)

  const status = document.createElement("span")
  status.textContent = "Status: " + item.status_code
  status.classList.add("terminal-row", "quarto-exit-code", colorClass)

  const spacer = document.createElement("span")
  spacer.classList.add("terminal-row", colorClass)

  terminal.appendChild(timestamp)
  terminal.appendChild(command)
  terminal.appendChild(origin)
  terminal.appendChild(target)
  terminal.appendChild(status)
  terminal.appendChild(spacer)
  item.stdout.map(item => {
    const elem = document.createElement("span")
    elem.textContent = item
    elem.classList.add("terminal-row", colorClass)
    terminal.appendChild(elem)
  })

  return contentItem
}

/** Create quarto table table row for a log item.
 *
 * Includes buttons to active the overlay and re-render, kind, origin, time,
 * target, and origin.
 * Highlights depending on success or failure of render.
 *
 * @param {QuartoRender} item - Log item pushed from websocket.
 * @returns a hydrated table row.
 *
 */
function hydrateQuartoLogItem(item) {
  const elem = document.createElement("tr")
  elem.classList.add(!item.status_code ? "quarto-success" : "quarto-failure")
  elem.classList.add("quarto-row")
  if (item.kind === "static") elem.classList.add("quarto-static")

  // RENDER CELL
  async function renderAction() {
    const renderIconSpinner = document.createElement("span")
    renderIconSpinner.classList.add("spinner-border")
    render.append(renderIconSpinner)
    renderIcon.classList.add("hidden")
    // NOTE: Since the row will show up with an error or not, do nothing with the 
    //       request response.
    await requestRender({ items: [item.target] })

    renderIconSpinner.remove()
    renderIcon.classList.remove("hidden")
  }

  const render = document.createElement("td")
  render.classList.add("quarto-log-render")

  const renderIcon = document.createElement("i")
  renderIcon.classList.add("bi", "bi-arrow-repeat")
  render.append(renderIcon)
  render.addEventListener("click", renderAction)


  // INFO CELL. This should be made to display the overlay later.
  const info = document.createElement("td")
  info.classList.add("quarto-log-info")

  const infoIcon = document.createElement("i")
  infoIcon.classList.add("bi", "bi-info-circle")

  info.append(infoIcon)

  // DATA CELLS
  const kind = document.createElement("td")
  const from = document.createElement("td")
  const time = document.createElement("td")
  const targetUrlPath = document.createElement("td")
  const target = document.createElement("td")
  const origin = document.createElement("td")

  kind.textContent = item.kind
  kind.classList.add("quarto-log-kind")
  if (item.kind == "direct") kind.classList.add("text-warning")
  else if (item.kind == "defered") kind.classList.add("text-primary")
  // else kind.classList.add("text-white");

  from.textContent = item.item_from
  from.classList.add("quarto-log-from")
  if (item.item_from == "client") from.classList.add("text-warning")
  // else from.classList.add("text-white")

  time.textContent = item.time
  time.classList.add("quarto-log-time")

  targetUrlPath.appendChild(handlePathlike(item.target_url_path, { wrapperTag: 'a' }))
  targetUrlPath.classList.add("quarto-log-target-url-path")

  target.appendChild(handlePathlike(item.target, {}))
  target.classList.add("quarto-log-target")

  origin.appendChild(handlePathlike(item.origin, {}))
  origin.classList.add("quarto-log-origin")


  elem.appendChild(info)
  elem.appendChild(render)
  elem.appendChild(kind)
  elem.appendChild(from)
  elem.appendChild(time)
  elem.appendChild(targetUrlPath)
  elem.appendChild(target)
  elem.appendChild(origin)

  // NOTE: Eventually statusCode should tell the overlay how to be colored.
  //       For now, overlay does not colorize until it is opened.
  elem.dataset.key = String(item.timestamp)

  const state = { highlight: false }
  const highlightClasses = ["highlight"]

  elem.addEventListener("click", () => {
    console.log(elem)
    state.highlight ? elem.classList.remove(...highlightClasses) : elem.classList.add(...highlightClasses)
    state.highlight = !state.highlight
  })

  return { elem, renderAction, info, render }
}

/**
 * @typedef {object} QuartoControlsOptions
 *
 * @property {Overlay} overlayInputs - Overlay to put api request inputs into.
 * @property {Overlay} overlayResponses - Overlay to display api responses in.
 * @property {Overlay} overlayRenders - Overlay to show all renders so far.
 * @property {string|null} [bannerTextInnerHTML] - Banner text message.
 *
 */



/** Create the render controls shown on the left hand side of the render banner.
 *
 * The following functionality should be achieved:
 *
 * 1. Tools should show up in their own overlay, where inputs are displayed
 *    and requests are sent to the API.
 * 2. Responses should be be shown in a separate overlay.
 * 3. Errors should be pushed to a separate overlay where they can be observed.
 *
 * @param {QuartoControlsOptions} options -
 *
 */
export function QuartoRenderBannerControls({ overlayInputs, overlayResponses, overlayRenders }) {

  /**
   * @param {object} options
   * @param {string} options.id -
   * @param {Array<string>} [options.classesButton] -
   * @param {string} [options.dataKey] -
   * @param {string} options.tooltip -
   * @param {string} [options.icon] -
   * @param {string} [options.text] -
   *
   */
  function createButton({ id, classesButton, dataKey, tooltip, icon, text }) {

    const button = document.createElement('button');
    if (id) button.id = id;
    button.type = 'button';
    button.classList.add("btn", ...(classesButton || []))

    if (dataKey) button.dataset.key = dataKey;
    if (tooltip) {
      button.setAttribute('data-bs-toggle', 'tooltip');
      button.setAttribute('data-bs-placement', 'top');
      button.setAttribute('title', tooltip);
      button.setAttribute('data-bs-custom-class', 'banner-tooltip')
    }

    if (icon) {
      const buttonIcon = document.createElement('i');
      buttonIcon.classList.add("bi", `bi-${icon}`);
      button.appendChild(buttonIcon);
    }

    if (text) {
      const textNode = document.createElement('text');
      textNode.textContent = text;
      button.appendChild(textNode);
    }

    return button;
  }

  async function quartoRenderCurrentAction() {
    buttons.quartoRenderCurrent.classList.add("btn-disabled")

    // const spinnerContainer = document.createElement("i")
    // spinnerContainer.classList.add("px-2")
    //
    // const spinner = document.createElement("div")
    // spinner.classList.add("spinner-border")
    // spinnerContainer.appendChild(spinner)
    // left.appendChild(spinnerContainer)
    //
    // spinnerContainer.remove()
    // left.appendChild(render)
    const res = await requestRender({})

    await res.json()
    buttons.quartoRenderCurrent.classList.remove("btn-disabled")
  }

  const buttons = {
    bannerClose: createButton({ icon: 'x-lg', id: 'quarto-controls-banner-close', tooltip: 'Close banner' }),
    bannerOverlay: createButton({ icon: 'info-circle', id: 'quarto-controls-banner-overlay', tooltip: 'Show Output' }),
    quartoRenderCurrent: createButton({ id: 'quarto-controls-render-current', icon: 'arrow-repeat', tooltip: 'Render This Page' }),
    // quartoGroup: createButton({ icon: 'bi-journal-code', text: 'Quarto' }),
    quartoRender: createButton({ id: 'quarto-controls-render', dataKey: 'render', tooltip: 'Render', icon: 'hammer' }),
    quartoGetRenderedLast: createButton({ id: 'quarto-controls-get-last', dataKey: 'get-last', tooltip: 'Last Rendered', icon: 'clock' }),
    quartoGetRendered: createButton({ id: 'quarto-controls-get-all', dataKey: 'get-all', tooltip: 'Render History', icon: 'clock-history' }),
    quartoClear: createButton({ id: 'quarto-controls-clear-renders', tooltip: 'Clear Renders', icon: 'trash' }),
    // serverGroup: createButton({ type: "button", icon: "server", text: "Server", }),
    serverClear: createButton({ id: "server-controls-clear-logs", tooltip: "Clear Logs", icon: "trash", }),
  }

  const elementButtons = document.createElement("div")
  elementButtons.classList.add("banner-controls-container")
  Object.values(buttons).map(btn => elementButtons.appendChild(btn))

  const element = document.createElement("div")
  element.classList.add("banner-controls")
  element.appendChild(elementButtons)

  const { quartoRenderCurrent, quartoRender, quartoClear, quartoGetRenderedLast, quartoGetRendered } = buttons
  quartoRenderCurrent.addEventListener("click", quartoRenderCurrentAction)

  const getRender = hydrateRender(quartoRender, { overlayInputs, overlayResponses })
  const clearQuarto = hydrateClearRenders(quartoClear, { overlayResponses })
  const getRenderedLast = hydrateGetLast(quartoGetRenderedLast, { overlayInputs, overlayResponses })
  const getRendered = hydrateGetAll(quartoGetRendered, { overlayInputs, overlayResponses })
  const clearLogs = hydrateClearLogs(quartoClear, { overlayResponses })

  // @ts-ignore
  const tooltips = [...element.querySelectorAll("button.btn[data-bs-toggle='tooltip']")].map(button => new bootstrap.Tooltip(button))

  // Append the container to the DOM
  return {
    element, buttons, actions: { quartoRenderCurrent: quartoRenderCurrentAction },
    closures: { getRender, clearQuarto, getRenderedLast, getRendered, clearLogs },
    tooltips,
  }
}


/** Create the render banner.
 *
 * @param {QuartoRender} logItem -
 * @param {QuartoOverlayItem} overlayItem -
 * @param {QuartoControlsOptions} options -
 */
export function QuartoRenderBanner(logItem, overlayItem, { overlayInputs, overlayResponses, overlayRenders, bannerTextInnerHTML }) {
  /* Re-render this page. */

  if (!overlayInputs || !overlayResponses || !overlayRenders) {
    console.warn(overlayInputs, overlayRenders, overlayResponses)
    throw Error("Could not find all required overlays.")
  }

  /* Ensure that the new banner is obvious to the user. */
  function show() {
    banner.classList.add("new")

    setTimeout(() => {
      banner.classList.remove("new")
    }, 1500)
  }

  function initialize() {
    // NOTE: Remove the banner if it already exists.
    const bannerOg = document.getElementById(identifier)
    if (bannerOg) bannerOg.remove()

    // NOTE: Make code elements and banner the right color.
    const classResult = !logItem.status_code ? "success" : "failure"
    banner.classList.add(successClass, classResult)
  }

  const identifier = "quarto-render-notification"

  // NOTE: Create the banner
  const successClass = !logItem.status_code ? "success" : "failure"
  const banner = document.createElement("div")
  banner.id = identifier

  const bannerContent = document.createElement("div")
  bannerContent.classList.add("banner-content")
  banner.appendChild(bannerContent)

  // NOTE: Create the banner controls.
  const bannerControls = QuartoRenderBannerControls({ overlayInputs, overlayResponses, overlayRenders })
  bannerControls.buttons.bannerClose.addEventListener("click", () => banner.remove())

  overlayItem && bannerControls.buttons.bannerOverlay.addEventListener("click", () => overlayItem.show())
  bannerContent.appendChild(bannerControls.element)


  // NOTE: Add banner text.
  const bannerTextContainer = document.createElement("div")
  bannerTextContainer.classList.add("banner-text-container")

  const bannerText = document.createElement("div")
  bannerText.classList.add("banner-text")
  bannerText.appendChild(bannerTextContainer)

  if (!bannerTextInnerHTML) {
    bannerTextContainer.innerHTML = `
      <text>Last rendered </text>
      <span></span>
      <text>at </text>
      <code class="fw-bolder">${logItem.time}</code>
      <text>from changes in </text>
      <span></span>
      <text>.</text>
    `

    // @ts-ignore
    const [target_mt, origin_mt] = bannerTextContainer.getElementsByTagName("span")

    const target = handlePathlike(logItem.target, { textTag: 'code', wrapperTag: 'span', iconClasses: ["px-1"] })
    target.classList.add("bg-black")
    target_mt.replaceWith(target)

    const origin = handlePathlike(logItem.origin, { textTag: 'code', wrapperTag: 'span', iconClasses: ["px-1"] })
    origin.classList.add("bg-black")
    origin_mt.replaceWith(origin)

  } else { bannerTextContainer.innerHTML = bannerTextInnerHTML }
  bannerContent.appendChild(bannerText)

  initialize()

  return { elem: banner, bannerControls, show, initialize }
}




/**
 * @typedef {Object} QuartoOptions
 *
 * @property {object|null} [filters] - Filters for websocket messages.
 * @property {number|null} [last] - Number of initial logs to recieve.
 * @property {HTMLElement} rendersTable - The table containing quarto logs.
 * @property {HTMLElement} rendersContainer - A div containing the renders container.
 * @property {Overlay} overlayRenders - Output from ``Overlay`` for overlay to contain render datas.
 * @property {QuartoControlsOptions|null} bannerOptions - Banner settings. When ``null``, the banner is not included.
 * @property {boolean|null} [reload] - Do page hot reloads.
 *
 */

/**
 * @typedef {object} QuartoOverlayItem
 *
 * @property {() => void} colorize -
 * @property {() => void} show -
 * @property {HTMLElement} elem -
 *
 */

/**
 * @typedef {object} QuartoLogItem
 *
 * @property {HTMLElement} elem -
 * @property {HTMLElement} render -
 * @property {HTMLElement} info -
 * @property {() => void} renderAction -
 * @property {() => void} show -
 *
 */

/**
 * @typedef {object} QuartoItem
 *
 * @property {QuartoLogItem | null} logItem
 * @property {QuartoOverlayItem} overlayItem
 *
 */



/** Handles new log items for the logs table *(if exists)* and banner *(if included).
 * 
 * - When a message arrives, ensure that a row is added to the display.
 * - When the message is an error, show the overlay with the page scrolled down to the bottom of the content.
 *
 * @param {QuartoOptions} options - 
*/
export function Quarto({ filters, last, rendersTable, rendersContainer, overlayRenders, bannerOptions, reload }) {

  const rendersTableContent = rendersTable ? rendersTable.querySelector("tbody") : null
  if (!overlayRenders) throw Error("Missing `overlayRenders`.")

  /** Add quarto render data content to overlayRenders (if the overlayRenders exists).
   *
   * @param {QuartoRender} item - Render log item from the websocket.
   * @returns {QuartoOverlayItem}
  */
  function QuartoOverlayItem(item) {
    const elem = hydrateQuartoOverlayItem(item)
    overlayRenders.addContent(elem)
    overlayRenders.overlayContentItems.appendChild(elem)

    function colorize() {
      overlayRenders.colorize({
        color: item.status_code ? "danger" : "primary",
        colorText: "white",
        colorTextHover: "black"
      })
    }

    function show() {
      LIVE_QUARTO_VERBOSE && console.log("Showing quarto renders overlay.")
      overlayRenders.showOverlay()
      overlayRenders.showOverlayContentItem(String(item.timestamp))
      colorize()
      setTimeout(() => overlayRenders.overlayContentItems.scrollTop = elem.scrollHeight, 100)
    }

    return { colorize, show, elem }
  }


  /** Create a log item and items actions.
   *
   * @param {QuartoRender} item - Render log item from the websocket.
   * @returns {QuartoLogItem | null}
  */
  function QuartoLogItem(item) {
    if (!rendersTable || !rendersTableContent) return null

    const logItem = hydrateQuartoLogItem(item)
    rendersTableContent.appendChild(logItem.elem)

    function show() {
      const classNew = item.status_code ? "border-red" : "border-teal"
      logItem.elem.classList.add(classNew, "border", "boder-3")

      // Add a border to indicate that the item is new.
      setTimeout(() => {
        logItem.elem.classList.remove(classNew)
        logItem.elem.classList.add("border-black")
      }, 1000)

      setTimeout(() => {
        logItem.elem.classList.remove("border-black", "border", "border-3")
      }, 30000)

    }

    return { ...logItem, show }
  }

  /** Add overlayRenders content (if possible) and log item (if possible).
   *
   * @param {QuartoRender} item - Render log item from the websocket.
   * @returns {QuartoItem}
  */
  function QuartoItem(item) {

    const overlayItem = QuartoOverlayItem(item)
    const logItem = QuartoLogItem(item)

    LIVE_QUARTO_VERBOSE && console.debug("Adding quarto overlayRenders item.", overlayItem)
    LIVE_QUARTO_VERBOSE && console.debug("Adding quarto log item.", logItem)

    if (logItem && overlayItem) logItem.info.addEventListener("click", overlayItem.show)

    return { overlayItem, logItem }
  }


  /** Handle updates for a single log item.
   *
   * @param {QuartoRender} logItem
   * @param {number} index
   * @param {QuartoRender[]} data
   *
   */
  function handleQuartoRender(logItem, index, data) {
    const item = QuartoItem(logItem)

    if (!state.isInitial) {
      if (item.overlayItem && logItem.status_code) item.overlayItem.show()
      if (item.logItem) item.logItem.show()
    }

    if (reload && logItem.status_code && index + 1 === data.length) item.overlayItem.show()

    if (reload && !state.isInitial && (logItem.target_url_path == window.location.pathname || logItem.target_url_path == window.location.pathname + "index.html")) {
      ws.close(1000)
      window.location.reload()
      return
    }

    if (bannerOptions) {
      const banner = QuartoRenderBanner(logItem, item.overlayItem, bannerOptions)

      document.body.appendChild(banner.elem)
      if (!state.isInitial || reload) {
        banner.show()
      }

      item.overlayItem && banner.bannerControls.buttons.bannerOverlay.addEventListener("click", item.overlayItem.show)
    }
  }

  /**
    If there is an overlayRenders, show an overlayRenders if there is an error.
    If there is a log, put the log item in and call `show` to make it obvious that it is new.
    If there is not a log, add a banner at the bottom of the page and call `show` to make it obvious that it is new.

    When there is data (when ``GET /api/dev/quarto`` would return ``HTTP 204``, do nothing.

    @param {any} event
  */
  function handleMessage(event) {
    const data = JSON.parse(event.data)
    if (!data) return

    LIVE_QUARTO_VERBOSE && data.target && console.log(`Recieved event for \`${data.target}\`.`)
    LIVE_QUARTO_VERBOSE && console.log(data)

    data.items.map(handleQuartoRender)

    if (state.isInitial) state.isInitial = false
    if (rendersContainer) rendersContainer.scrollTop = rendersContainer.scrollHeight
  }

  const state = { isInitial: true }

  let url = '/api/dev/quarto'
  if (last) { url = url + `?last=${last}` }
  const ws = new WebSocket(url)

  function initialize() {
    // NOTE: Send in filters for listener so it will start listening.

    createWebsocketTimer(ws)
    ws.addEventListener("open", () => {
      ws.send(JSON.stringify(filters || null))
      if (LIVE_QUARTO_VERBOSE) {
        console.log("Websocket connection opened for quarto renders.")
        console.log(`Websocket sent filters \`${JSON.stringify(filters || null, null, 2)}\`.`)
      }
    })

    ws.addEventListener("message", handleMessage)
    LIVE_QUARTO_VERBOSE && ws.addEventListener("close", (event) => console.log(event))
  }

  initialize()
  const closure = { ws, initialize, state, handleMessage, overlayRenders: overlayRenders, rendersTable: rendersTable, rendersContainer: rendersContainer }

  QuartoInstances.set("it", closure)
  return closure
}


// ------------------------------------------------------------------------- //
// Controls


/** Add response to the responses overlay.
 *
 * @param {Response} response -
 * @param {object} options -
 * @param {object} options.overlayResponses -
 *
 */
async function hydrateServerResponse(response, { overlayResponses }) {
  const colorClass = response.ok ? "text-green" : "text-red"

  const url = document.createElement("span")
  url.textContent = `URL: ${response.url}`
  url.classList.add("terminal-row", colorClass)

  const status = document.createElement("span")
  status.textContent = `Status Code: ${response.status} ${response.statusText}`
  status.classList.add("terminal-row", colorClass)

  const container = document.createElement("div")
  container.classList.add("terminal")

  container.innerHTML = ''
  container.appendChild(url)
  container.appendChild(status)

  const responseText = await response.text()
  try {
    const json = JSON.parse(responseText);
    const responseBody = JSON.stringify(json, null, 2); // Pretty print with 2 spaces

    responseBody.split("\n").map(
      line => {
        const elem = document.createElement("span")
        elem.classList.add("terminal-row", colorClass)
        elem.textContent = line
        container.appendChild(elem)
      }
    )

  } catch (e) {
    const content = document.createElement("span")
    content.classList.add(colorClass)
    content.textContent = `Response: ${responseText}`
  }

}

/**
 * @typedef {object} Input
 *
 * @property {HTMLElement} elem
 * @property {HTMLInputElement|HTMLSelectElement} input
 * @property {HTMLElement} errorMsg
 * @property {HTMLElement} [text]
 * @property {() => void } onInvalid
 * @property {() => void } onValid
 *
 */


/** Create input group for enum and helpers.
 *
 * @param {string} baseId
 * @param {object} options - Additional configuration options.
 * @param {string} [options.selectInnerHTML] - Select options
 * @returns {Input}
 *
 */
function hydrateInputKind(baseId, { selectInnerHTML } = {}) {
  const inputGroup = document.createElement("div")
  inputGroup.classList.add("input-group", "bg-black", "my-4", "flex-wrap")

  // Create the input.
  const input = document.createElement("select")
  input.classList.add("form-select", "w-100")
  input.id = `api-params-${baseId}-kind`
  input.innerHTML = selectInnerHTML || `
    <option value="none" selected>Select Render Kind</option>
    <option value="direct">Direct</option>
    <option value="defered">Defered</option>
    <option value="static">Static</option>
  `
  inputGroup.append(input)

  // NOTE: Create the error message.
  const inputErrorMsg = document.createElement("div")
  inputErrorMsg.classList.add("form-text", "text-warning", "hidden")
  inputErrorMsg.id = `api-params-${baseId}-err`
  inputErrorMsg.innerHTML = `
    <i class="bi bi-info-circle"></i>
    <text>At least one kind must be selected.</text>
  `
  inputGroup.append(inputErrorMsg)

  function onInvalid() {
    inputErrorMsg.classList.remove("hidden")
    input.classList.add("border", "border-warning", "border-3")
  }

  function onValid() {
    inputErrorMsg.classList.add("hidden")
    input.classList.remove("border", "border-warning", "border-3")
  }

  return { elem: inputGroup, input, errorMsg: inputErrorMsg, onInvalid, onValid }
}


/**
 * @param {string} baseId
 * @returns {Input}
 */
function hydrateInputItems(baseId) {
  const inputGroup = document.createElement("div")
  inputGroup.classList.add("input-group", "my-4", "flex-wrap")

  const input = document.createElement("input")
  input.type = "text"
  input.classList.add("form-control", "w-100")
  input.id = `api-params-${baseId}-item`
  inputGroup.append(input)

  const inputText = document.createElement("div")
  inputText.classList.add("form-text")
  inputText.id = `api-params-${baseId}-desc`
  inputText.innerHTML = `
      <i class="bi bi-file-earmark"></i>
      <text>Enter the absolute url to the file to re-render.</text>
    `
  inputGroup.append(inputText)

  const inputErrorMsg = document.createElement("div")
  inputErrorMsg.classList.add("form-text", "text-warning", "hidden")
  inputErrorMsg.id = "api-params-render-err"
  inputErrorMsg.innerHTML = `
      <i class="bi bi-info-circle"></i>
      <text>The provided value must be a valid path.</text>
    `
  inputGroup.append(inputErrorMsg)

  function onInvalid() {
    inputErrorMsg.classList.remove("hidden")
    inputText.classList.add("hidden")
    input.classList.add("border", "border-warning", "border-3")
  }

  function onValid() {
    inputErrorMsg.classList.add("hidden")
    inputText.classList.remove("hidden")
    input.classList.remove("border", "border-warning", "border-3")
  }


  return { elem: inputGroup, input, text: inputText, errorMsg: inputErrorMsg, onValid, onInvalid }
}

/**
 * @param {string} baseId
 * @param {object} options
 * @param {Overlay} options.overlayInputs
 * @param {string} [options.title]
 * @param {string} [options.submitText]
 * @param {Input[]} options.inputs
 */
function hydrateForm(baseId, { overlayInputs, title, submitText, inputs }) {
  if (!overlayInputs) throw Error("Missing `overlayInputs`.")

  // NOTE: Create the overlay content item.
  const elem = document.createElement("div")
  elem.classList.add("overlay-content-item")
  elem.dataset.key = baseId

  // NOTE: Create the header.
  elem.innerHTML = `<h4 class="my-5">${title}</h4>`

  // NOTE: Create the form container.
  const form = document.createElement("div")
  form.id = `api-params-${baseId}`
  form.classList.add("m-3")
  elem.appendChild(form)
  if (inputs) inputs.map(item => form.appendChild(item.elem))

  // NOTE: Create the button.
  const button = document.createElement("button")
  button.id = `api-params-${baseId}-button`
  button.type = "button"
  button.classList.add("btn", "my-5")

  const spinner = document.createElement("span")
  spinner.classList.add("spinner-border", "spinner-border-sm", "hidden")
  spinner.role = "status"

  const text = document.createElement("text")
  text.innerText = " " + (submitText || "Submit")

  button.appendChild(spinner)
  button.appendChild(text)
  elem.appendChild(button)

  if (!overlayInputs.state.colorize) throw Error()
  const updateButtonColor = overlayInputs.state.colorize.updateElem(button, (color) => [`btn-outline-${color}`])
  updateButtonColor()

  /* Button is no longer disabled, hide spinner, hide overlay, revert error color */
  function onRequestOver() {
    overlayInputs.hideOverlay()

    button.classList.remove("disabled")
    spinner.classList.add("hidden")
    updateButtonColor()
  }

  /* Disable button and make spinner visible */
  function onRequestSent() {
    elem.dataset.colorizeColor = "primary"

    // @ts-ignore
    overlayInputs.state.colorize.restart({ color: "primary" })
    spinner.classList.remove("hidden")
    button.classList.add("disabled")
    updateButtonColor()
  }


  /* Does not update form elements. */
  function onInvalid() {
    elem.dataset.colorizeColor = "warning"
    overlayInputs.colorize({ color: "warning" })
    updateButtonColor()
  }

  overlayInputs.overlayContentItems.appendChild(elem)
  overlayInputs.addContent(elem)
  elem.dataset.colorizeColor = "primary"

  return { elem, form, button, updateButtonColor, onRequestOver, onRequestSent, onInvalid }
}

/** 
 * @param {HTMLElement} elem
 * @param {object} options
 * @param {Overlay} options.overlayResponses
 * @param {Overlay} options.overlayInputs
 * @returns {void}
 */
function hydrateGetAll(elem, { overlayResponses, overlayInputs }) {
  async function action() {
    overlayInputs.showOverlay()
    overlayInputs.showOverlayContentItem("get-all")
  }

  // const elem = document.querySelector("#quarto-controls-get-all")
  elem.addEventListener("click", action)
  const baseId = "get-all"

  // NOTE: Spawn the form.
  const inputKind = hydrateInputKind(baseId)
  const formContentItem = hydrateForm(baseId, {
    title: "Get All",
    overlayInputs: overlayInputs,
    inputs: [inputKind]
  })


  // NOTE: Add form listeners.
  formContentItem.button.addEventListener("click", async () => {
    formContentItem.onRequestSent()
    hydrateServerResponse(
      await requestRenderHistory({ kind: inputKind.input.value === 'none' ? null : [inputKind.input.value] }),
      { overlayResponses }
    )
    formContentItem.onRequestOver()
  })

  formContentItem.updateButtonColor()
}


/**
 * @param {HTMLElement} elem
 * @param {object} options
 * @param {Overlay} options.overlayResponses
 * @param {Overlay} options.overlayInputs
 */
function hydrateRender(elem, { overlayInputs, overlayResponses }) {
  async function action() {
    overlayInputs.showOverlay()
    if (!elem.dataset.key) throw Error()
    overlayInputs.showOverlayContentItem(elem.dataset.key)
  }

  // const elem = document.querySelector("#quarto-controls-render")
  elem.addEventListener("click", action)

  const baseId = "render"
  const inputItems = hydrateInputItems(baseId)
  const inputKind = hydrateInputKind(
    baseId,
    {
      selectInnerHTML: `
        <option value="file" selected>File</option>
        <option value="directory">Directory</option>
      `
    }
  )

  const formContentItem = hydrateForm(baseId, { title: "Render By URL", overlayInputs, inputs: [inputItems, inputKind] })

  formContentItem.button.addEventListener("click", async () => {
    if (!inputItems.input.value) {
      inputItems.onInvalid()
      formContentItem.onInvalid()
      inputKind.onInvalid()
      return
    }
    else {
      inputItems.onValid()
      inputKind.onValid()
    }

    formContentItem.onRequestSent()
    const items = [{ path: inputItems.input.value, kind: inputKind.input.value }]
    hydrateServerResponse(await requestRender({ items: items }), { overlayResponses })
    formContentItem.onRequestOver()
  })

  return { elem, formContentItem, inputItems }
}


/**
 * @param {HTMLElement} elem
 * @param {object} options
 * @param {Overlay} options.overlayResponses
 */
function hydrateClearLogs(elem, { overlayResponses }) {
  async function action() {
    const response = await fetch("/api/dev/log", { method: "DELETE" })
    await hydrateServerResponse(response, { overlayResponses })
  }

  // const elem = document.querySelector("#server-controls-clear-logs")
  elem.addEventListener("click", action)

  return { elem, action }
}


/**
 * @param {HTMLElement} elem
 * @param {object} options
 * @param {Overlay} options.overlayResponses
 */
function hydrateClearRenders(elem, { overlayResponses }) {
  async function action() {
    const response = await fetch("/api/dev/quarto", { method: "DELETE" })
    await hydrateServerResponse(response, { overlayResponses })
  }


  // const elem = document.querySelector("#quarto-controls-clear-renders")
  elem.addEventListener("click", action)

  return { elem, action }
}




/**
 * @param {HTMLElement} elem
 * @param {object} options
 * @param {Overlay} options.overlayInputs
 * @param {Overlay} options.overlayResponses
 */
function hydrateGetLast(elem, { overlayInputs, overlayResponses }) {
  async function action() {
    overlayInputs.showOverlay()
    overlayInputs.showOverlayContentItem("get-last")
  }

  elem.addEventListener("click", action)

  const baseId = "get-last"
  const inputKind = hydrateInputKind(baseId, {})
  const formContentItem = hydrateForm(baseId, { overlayInputs, inputs: [inputKind], title: "Render by URL" })

  formContentItem.button.addEventListener("click", async () => {

    if (inputKind.input.value === 'none') {
      formContentItem.onInvalid()
      inputKind.onInvalid()
      return
    }
    else inputKind.onValid()

    formContentItem.onRequestSent()
    hydrateServerResponse(await requestLast({ kind: [inputKind.input.value] }), { overlayResponses })
    formContentItem.onRequestOver()
  })


  return { elem }
}


/*
export function QuartoControls() {
  const overlay = Overlay(document.getElementById("api-params"))
  overlay.colorize({ color: "primary", colorText: "white", colorTextHover: "black" })

  const render = hydrateRender(overlay)
  const clearLogs = hydrateClearLogs()
  const clearQuarto = hydrateClearRenders()
  const getLast = hydrateGetLast(overlay)
  const getAll = hydrateGetAll(overlay)

  return { overlay, render, clearLogs, clearQuarto, getLast, getAll }
}
*/
