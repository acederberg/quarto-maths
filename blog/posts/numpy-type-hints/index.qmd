---
title: On The State NumPY Type Hints
---

I wrote this up while initially messing around with [molten-nvim](https://github.com/benlubas/molten-nvim/blob/main/README.md).

::: { .callout-note }

## About Type Hints for Numpy N-Dimensional Arrays

First, a few notes on @fig-cartioid-script are warrented:

- [PEP 646](https://typing.readthedocs.io/en/latest/spec/generics.html#typevartuple)
  proposed `TypeVarTuple` and was accepted in `python3.11`. This makes it
  possible to parametrize a type using an arbitrary number of parameters.
- PEP 646 is supported by `mypy`.
- [PR #17719 on numpy](https://github.com/numpy/numpy/pull/17719) adds shape
  parametrization to `np.ndarray`.
- Type hints for `NDArray` are still not complete or practical, see
  [this comment](https://github.com/numpy/numpy/issues/16544#issuecomment-1804251364).
- [Type hints for `NDArray` are not going be checked by
  `pyright`](https://github.com/microsoft/pyright/issues/8921#issuecomment-2336434767),
  which is the type checker I like to run in my `quarto` notebooks.

With that out of the way, I would like to say that **the type hints in the
following code are mostly for my own experimentation and are _possibly incorrect_**.
The objective is to have `SeriesPlotter` have correct type hints for the
attributes `sequence` and `series`, which should include the size of the numpy
arrays.

To do this, `SeriesPlotter` is a generic of two parameters - the first
specifies the number of points in the input space and the second specifies the
number of elements in the series.

:::

The objective of the code in @fig-cartioid-script is to plot cartioid like
graphs using [polar coordinates (via `matplotlib`)](https://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_demo.html)
with **type hints that will hopefully be valid once `mypy` supports PEP 646**.

::: { #fig-cartioid-numpy }

```{python}

import functools
import math
from typing import Any, Generic, Literal, Protocol, TypeVar
from matplotlib.animation import FuncAnimation
from matplotlib.axes import Axes
from matplotlib.lines import Line2D
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.projections.polar import PolarAxes
from numpy.typing import NDArray

FloatArray = NDArray[np.float64]
FloatArraySequenceHeight = TypeVar("FloatArraySequenceHeight", bound=int)
FloatArraySequenceWidth = TypeVar("FloatArraySequenceWidth", bound=int)
FloatArraySequence = np.ndarray[
    tuple[FloatArraySequenceHeight, FloatArraySequenceWidth], np.dtype[np.float64]
]
Kind = Literal["series", "sequence"]


class SeriesGenerator(Protocol):
    def __call__(self, theta: FloatArray, index: int) -> FloatArray: ...


T_PlotCallbackAxes = TypeVar(
    "T_PlotCallbackAxes", Axes, PolarAxes, contravariant=True, covariant=False
)


class PlotCallback(Protocol, Generic[T_PlotCallbackAxes]):
    """Used to provide callbacks to animation methods."""

    def __call__(
        self, axs: T_PlotCallbackAxes, line: Line2D, frame: int
    ) -> tuple[Line2D]: ...


class SeriesPlotter(Generic[FloatArraySequenceHeight, FloatArraySequenceWidth]):
    """

    :ivar width: Precision of sequence (number of terms). The second parameter of the generic should match this.
    :ivar height: Number of points in the input space. The first parameter of the generic should match this.
    """

    height: int
    width: int
    func: SeriesGenerator
    theta: FloatArray
    sequence: FloatArraySequence[FloatArraySequenceHeight, FloatArraySequenceWidth]
    series: FloatArraySequence[FloatArraySequenceHeight, FloatArraySequenceWidth]

    def __init__(
        self,
        func: SeriesGenerator,
        *,
        height: FloatArraySequenceHeight,
        width: FloatArraySequenceWidth,
        theta: FloatArray | None = None,
    ):

        self.func = func
        self.height = height
        self.width = width

        self.theta = theta or np.linspace(0, 2 * math.pi, self.height)
        self.sequence = self.create_series_sequence()
        self.series = self.create_series()

    def create_series_sequence(
        self,
    ) -> FloatArraySequence[FloatArraySequenceHeight, FloatArraySequenceWidth]:
        """
        Given a series whose members are the sequence `a_n`, return
        `{a_k: where k is positive and less than 'series_length'}`

        `create_series` can be used to sum these elements together.
        """

        return np.array([self.func(self.theta, index) for index in range(self.width)])

    def create_series(
        self,
    ) -> FloatArraySequence[FloatArraySequenceHeight, FloatArraySequenceWidth]:
        return np.array([sum(self.sequence[: k + 1]) for k in range(0, self.width)])

    def create_subplots(
        self,
        rows: int,
        cols: int,
        *,
        kind: Kind = "series",
        subplot_kw: dict[str, Any] = {"projection": "polar"},
    ):
        """Put series or sequences into (polar) subplots."""

        coords = self.sequence if kind == "sequence" else self.series
        fig, axs = plt.subplots(rows, cols, subplot_kw=subplot_kw)
        positions = (
            (k, k // cols, k % cols) for k in range(rows * cols) if k < self.width
        )

        ax: PolarAxes
        for k, row, column in positions:
            ax = axs[row][column]
            ax.plot(self.theta, coords[k], linewidth=0.8)

        return fig

    def frame_animation_rect(
        self, axes: Axes, line: Line2D, frame: int, *, coords
    ) -> tuple:
        """Animated a single frame."""

        frame_f = coords[frame]
        line.set_ydata(frame_f)
        line.set_label(f"n = {frame + 1}")
        axes.legend(handles=[line])

        return (line,)  # if callback is None else callback(line)

    def create_animation_rect(self, kind: Kind = "series"):
        """
        Create an animation of the series or sequence in increasing precision
        in rectilinear coordinates.
        """

        coords = self.series if kind == "series" else self.sequence
        frames = list(range(self.width))

        axs: Axes
        fig, axs = plt.subplots(1, 1)
        # axs.set_ylim(-1.2, 1.2)
        axs.set_title("Sawtooth Wave Foureir Series")

        (line,) = axs.plot(self.theta, self.series[0])
        line.set_label("n = 1")
        axs.legend(handles=[line])

        fn = functools.partial(self.frame_animation_rect, axs, line, coords=coords)
        return FuncAnimation(fig, fn, frames=frames, interval=333)

    def create_animation(self):
        """Plot seriesi or equence members in polar coordinates."""
        ...
```

:::

## A Leaf Like Cartioid

First, I should say that most cartioids vaguely resemble leafs - I just didn't
know what to call this one.

::: { #fig-cartioid-leafy-script }

```{python}

class LeafyPlotter(SeriesPlotter[FloatArraySequenceHeight, FloatArraySequenceWidth]):
    @staticmethod
    def fn(theta: FloatArray, index: int) -> FloatArray:
        return np.cos(theta * (3**index)) / (index + 1)

    def frame_animation_rect(
        self, axes: Axes, line: Line2D, frame: int, *, coords
    ) -> tuple:
        bound = max(
            abs(min(coords[frame])),
            abs(max(coords[frame])),
        )
        axes.set_ylim(-bound, bound)

        return super().frame_animation_rect(axes, line, frame, coords=coords)

    def __init__(
        self,
        *,
        height: FloatArraySequenceHeight,
        width: FloatArraySequenceWidth,
        theta: FloatArray | None = None
    ):
        super().__init__(self.fn, height=height, width=width, theta=theta)


leafy_plotter = LeafyPlotter[Literal[1000], Literal[8]](height=1000, width=8)
leafy_figure = leafy_plotter.create_subplots(2, 2, kind="series")
leafy_figure.savefig("./leafy.svg", format="svg")
plt.close()

leafy_animation = leafy_plotter.create_animation_rect()
leafy_animation.save("leafy-rectilinear.gif")
plt.close()
```

:::

![Leafy cartioid](./leafy.svg){ #fig-cartioid-leafy-polar }

![Leafy cartioid animation](./leafy.svg){ #fig-cartioid-leafy-rect }

## The Sawtooth Cartioid

Next I wanted to plot a sawtooth wave using a Foreir series on this interval.
The Fourier series can be calculated using the `sine` transform of the mapping
$f: x\mapsto x$ for $x\in (-\pi, \pi)$ like

\begin{equation}
a*n = \frac{1}{\pi}\int*{-\pi}^{\pi} xsin(nx) dx
\end{equation}

and

\begin{equation}
b*n = \frac{1}{\pi}\int*{-\pi}^\pi xcos(nx) dx = \frac{2(-1^{k+1})}{n \pi}
\end{equation}

Since the integrands of $a_n$ are odd about the center of the interval the
integral will be zero - $a_n = 0$ for all $n$, so $f$ can be approximated
(where it is continuous) like

\begin{equation}
\sum\_{k=1}^\infinity \frac{2(-1^{k+1})}{n \pi}
\end{equation}

With this information we can write the following python function:

::: { #fig-sawtooth-script }

```{python}

class SawtoothPlotter(SeriesPlotter[FloatArraySequenceHeight, FloatArraySequenceWidth]):
    @staticmethod
    def fn(theta: FloatArray, index: int) -> FloatArray:
        """Computes the term `a_{index}` of the Fourier series for the sawtooth wave."""

        if index < 0:
            raise ValueError

        index += 1
        constant = (1 if index % 2 else -1) / index
        constant *= 2 / np.pi

        return constant * np.sin(theta * index)

    def frame_animation_rect(
        self, axes: Axes, line: Line2D, frame: int, *, coords
    ) -> tuple:
        axes.set_ylim(-1.2, 1.2)
        return super().frame_animation_rect(axes, line, frame, coords=coords)

    def __init__(
        self,
        *,
        height: FloatArraySequenceHeight,
        width: FloatArraySequenceWidth,
        theta: FloatArray | None = None
    ):
        super().__init__(self.fn, height=height, width=width, theta=theta)


sawtooth_plotter = SawtoothPlotter[Literal[1440], Literal[32]](height=1440, width=32)
sawtooth_animation = sawtooth_plotter.create_animation_rect("series")
sawtooth_animation.save("sawtooth.gif")
plt.close()

sawtooth_figure = sawtooth_plotter.create_subplots(4, 4)
sawtooth_figure.savefig("./sawtooth.svg", format="svg")
plt.close()
```

:::

![Sawtooth wave approximated using a forier series](./sawtooth.svg){#fig-sawtooth-polars}

![This cardioid is generated in @fig-cartioid-script](./sawtooth.gif){ #fig-sawtooth-gif }

![Molten in Action.](~/Pictures/Screenshots/neovim-gallery/molten.gif){#fig-molten}

<!-- For more on generating polar graphs in `matplotlib`, see -->
<!-- [the documentation on polar projections](https://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_demo.html). -->
