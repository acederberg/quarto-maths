---
title: "The Logistic Map and Chaos"
---


## The Logistic Map


The **logistic map** is defined as

\begin{equation}
  l_r: x \mapsto rx(1-x)
\end{equation}

where $r \in [0, 4]$ and $x \in [0, 1]$. The **logistic sequence** is defined 
as

\begin{equation}
  \lambda_r = \{l_r^k(x_0): k \in N\}
\end{equation}

for some $x_0 \in [0, 1]$. It is easy to write out some ``python`` functions 
that will compute the values of the logistic sequence:


```{python}
#| echo: true
import itertools
import os
import pathlib
from os import environ
from typing import Generator, List

import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


# NOTE: Constants. These will determine how long it will take for this document
#       to render.
LOGISTIC_STEP_SIZE = float(environ.get("LOGISTIC_STEP_SIZE", "0.05"))
LOGISTIC_ITERATIONS = int(environ.get("LOGISTIC_ITERATIONS", "1000 "))
LOGISTIC_ITERATIONS_KEPT = int(environ.get("LOGISTIC_ITERATIONS_KEPT", "100"))

LOGISTIC_COMPOSITION_FRAMES = 7 

QUARTO_POSTS = pathlib.Path(".").resolve()
LOGISTIC_DATA = QUARTO_POSTS.parent / "demo-data" / "posts" / "logistic_data"
LOGISTIC_DATA_BIFURCATION = LOGISTIC_DATA / f"logistic-bifurcation-{LOGISTIC_ITERATIONS}-{LOGISTIC_STEP_SIZE}.csv"


def logistic_point(
  rr: float, 
  xx: float, 
  *, 
  power: int = 1,
  _power: int = 0,
) -> float:
  """Compute the value of the logistic map for some coefficient `rr` and 
  number `xx`.
  """
  
  xx_next = rr * xx * (1 - xx) 
  if _power == power:
    return xx_next

  return logistic_point(rr, xx_next, power=power, _power=_power+1)


def _logistic_array(rr: float, xx, *, power = 1):
  """Helper for ``logistic_array``."""

  # NOTE: Numpy multiplies elements stepwise.

  yy, _power = xx, 0
  while _power < power:
    yy = rr * yy * (1 - yy)
    _power = _power + 1

  return yy


def logistic_array(
  rr: float,
  *,
  step: float = 0.001,
  power: int = 1,
):
  """Compute the graph of the logistic map on the closed interval $[0, 1]$."""

  xx = np.arange(0, 1 + step, step=step)
  yy = _logistic_array(rr, xx, power=power)

  return pd.DataFrame(dict(xx=xx, yy=yy))


def logistic_point_sequence(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
) -> Generator[float, None, None]:
  """Iterate the logistic sequence starting at `xx` for coefficient `rr` for
  `iterations` number of steps."""

  yield xx 

  iteration = 0
  while (iteration := iteration + 1) < iterations:
    yield (xx := logistic_point(rr, xx))


def logistic_point_attractor(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept = LOGISTIC_ITERATIONS_KEPT,
) -> List[float]:

  seq = enumerate(logistic_point_sequence(rr, xx,  iterations=iterations)) 
  pos_min = iterations - iterations_kept 
  return [value for pos, value in seq if pos >= pos_min]

```

Using the above functions it is possible to make some nice graphs of the 
logistic function and its composition with itself. The graphs are generated 
inside of this ``quarto`` document using ``matplotlib`` and ``numpy`` with the 
following ``python`` code:

```{python}
#| label: logistic-composition
#| fig-cap: $\lambda_4^k$ for $k \in N$ and $0 < k < 7$. Press the play button to show the animation.
from IPython.display import HTML
import matplotlib.pyplot as plt

from matplotlib.animation import FuncAnimation


def update(frame):
  line.set_ydata(data[frame]["yy"])

  tx.set_text(f"k = {frame}")
  return ( line,)

data = [logistic_array(4, power=k + 1) for k in range(LOGISTIC_COMPOSITION_FRAMES)]
fig, ax = plt.subplots()
tx = ax.text(0, 1.1, "k = 0")

line, = ax.plot(data[0]["xx"], data[0]["yy"])
animation = FuncAnimation(fig, update, frames=LOGISTIC_COMPOSITION_FRAMES)

plt.close()
HTML(animation.to_jshtml())
```


## Bifurcation Diagram

Below is the bifurcation diagram for the logistic map. A bifurcation diagram
is used to show the regions of attraction for the sequence depending on `rr`.

This graph is generated by iterating over the values of `rr` on the closed 
inverval `[0, 4]` and completing the following process for each `rr`:

1. Generate a random starting point `x0`.
2. Do a large number of iterations.
3. Choose some final number of terminating sequence elements to plot.

A few well known facts about the logistic map are appearent from the figure:

- Below a value of three, the logistic sequence actually converges 
- Above the value of three, the logistic map will tend to converge to cycles.
  That is, the logistic map will be a union of convergent subsequences but is 
  not itself convergent .
- The bifurcation cascade continues as the value of ``rr`` increases.

```{python}
def logistic_bifurcation_data(
  *,
  start: float = float(2), 
  stop: float = float(4),
  step: float = 0.05,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept: int = LOGISTIC_ITERATIONS_KEPT,
):
  """Returns a ``DataFrame`` containing coefficients, attractors, and initial
  conditions.
  """

  rs = np.arange(start, stop, step)
  x0s =  list( np.random.rand() for _ in range(len(rs)))

  return pd.DataFrame(
    dict(
      rr=rs,
      x0=x0s,
      attractors=list(
        logistic_point_attractor(
          rr, 
          x0,
          iterations=iterations,
          iterations_kept=iterations_kept,
        )
        for rr, x0 in zip(rs, x0s)
      ) 
    )
  )


def create_data():
  """Load data if it has already been computed. This is especially useful when
  developing this document."""

  if not LOGISTIC_DATA.exists():
    os.mkdir(LOGISTIC_DATA)

  if not LOGISTIC_DATA_BIFURCATION.exists():
    data_raw = logistic_bifurcation_data(step=0.0001)

    rr = [rr for rr in data_raw["rr"] for _ in range(LOGISTIC_ITERATIONS_KEPT)] 
    xx =list(itertools.chain(*data_raw["attractors"]) )
    data = pd.DataFrame(dict(rr=rr, xx=xx))
    data.to_csv(LOGISTIC_DATA_BIFURCATION)
  else:
    data = pd.read_csv(LOGISTIC_DATA_BIFURCATION)

  return data
```


## Cobweb Diagram

A cobweb diagram can be used to visual the covergence of a logistic sequence.
The procedure for creating the diagram is as follows:

1. An initial input ``x0`` is chosen. This can be written as the point 
   ``(x0, x0)`` on the graph.
2. The output ``y0 = logistic_point(x0)`` is computed. This can be written as 
   the point ``(x0, y0)``.
3. The next point will be ``(y0, y0)``, directly on the line defined as
   ``x = y``. This helps find the next input into the logistic map.
4. Since the next input into the logistic map is ``y0``, we follow the ``x``
   projection onto the logistic maps graph to get ``(y0, logistic_point(y0))``.
   This step is realy just the same as step ``2``.

In the most explicit form this is

\begin{multline}
\{ \\
  (x_0, x_0), \\
  (x_0, \lambda_r(x_0)), (\lambda_r(x_0), \lambda(x_0)), \\
  (\lambda(x_0), \lambda^2(x_0)), (\lambda^2(x_0), \lambda^2(x_0))), \\
  (\lambda^2(x_0), \lambda^3(x_0)), (\lambda^3(x_0), \lambda^3(x_0)), \\
  ... \\
  (\lambda^{k-1}(x_0), \lambda^{k}(x_0)), (\lambda^k(x_0), \lambda^k(x_0)), \\
  ...
\}
\end{multline}

Moreover, if $l_r = \{a_k := \lambda^k_r(x_0), k \in N\}$ is a logistic 
sequence, then we are just plotting

\begin{equation}
\{
  (a_0, a_0), (a_0, a_1), (a_1, a_1), (a_1, a_2), (a_2, a_2), ..., 
  (a_k, a_{k+1}), (a_{k+1}, a_{k+1}), ...
\}
\end{equation}

This can be done using the following code:

```{python}
#| label: fig-logistic-cobweb
#| fig-cap: "Logistic Cobweb Diagram."

def logistic_cobweb_sequence(
  rr: float,
  x0: float,
  *, 
  iterations: int = LOGISTIC_ITERATIONS,
):
  iteration = 0 

  yield (xx := x0, xx) # 1
  while (iteration := iteration + 1) < iterations:
    yield (xx, yy := logistic_point(rr, xx)) # 2
    yield (xx := yy, yy) # 3


def logistic_cobweb(
  rr: float,
  x0: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
):
  points = logistic_cobweb_sequence(rr, x0, iterations=iterations)
  xx, yy = zip(*points) 
  for xx_coords, yy_coords in zip(
      zip(xx[:-1], xx[1:]),
      zip(yy[:-1], yy[1:])
  ):
    yield pd.DataFrame(dict(xx=xx_coords, yy=yy_coords))


# TODO: Animate this over x0.
rr = 3.8 # type: ignore
x0 = 0.4 # type: ignore

data = logistic_array(rr)
sns.lineplot(data=data, x="xx", y="yy")
sns.lineplot(data=data, x="xx", y="xx")

for line in logistic_cobweb(rr, x0, iterations=100):
  sns.lineplot(
    data=pd.DataFrame(line),
    x="xx",
    y="yy",
    color="red",
  )

plt.xlim(0, 1)
plt.ylim(0, 1)
```



