---
title: "The Logistic Map and Chaos"
---


## The Logistic Map


The **logistic map** is defined as

\begin{equation}
  l_r: x \mapsto rx(1-x)
\end{equation}

where $r \in [0, 4]$ and $x \in [0, 1]$. The **logistic sequence** is defined 
as

\begin{equation}
  \lambda_r = \{l_r^k(x_0): k \in N\}
\end{equation}

for some $x_0 \in [0, 1]$. It is easy to write out some ``python`` functions 
that will compute the values of the logistic sequence:


```{python}
#| echo: true
import itertools
import json
import os
import pathlib
from os import environ
from typing import Generator, List

import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import HTML
from matplotlib.animation import FuncAnimation




# NOTE: Constants. These will determine how long it will take for this document
#       to render. Further, changing these documents can result in an error 
#       from deno with the message ``ERROR: RangeError: Maximum call stack size 
#       exceeded``.
LOGISTIC_X0_DEFAULT = float(environ.get("LOGISTIC_X0_DEFAULT", "0.9"))
LOGISTIC_STEP_SIZE = float(environ.get("LOGISTIC_STEP_SIZE", "0.01"))
LOGISTIC_STEP_SIZE_RR = float(environ.get("LOGISTIC_STEP_SIZE_RR", "0.02"))
LOGISTIC_ITERATIONS = int(environ.get("LOGISTIC_ITERATIONS", "1000 "))
LOGISTIC_ITERATIONS_KEPT = int(environ.get("LOGISTIC_ITERATIONS_KEPT", "100"))

QUARTO_POSTS = pathlib.Path(".").resolve()
LOGISTIC_DATA = QUARTO_POSTS.parent / "demo-data" / "posts" / "logistic_data"
LOGISTIC_DATA_BIFURCATION = LOGISTIC_DATA / f"logistic-bifurcation-{LOGISTIC_ITERATIONS}-{LOGISTIC_STEP_SIZE}.csv"
LOGISTIC_DATA_COBWEB_RR = LOGISTIC_DATA / f"cobweb-{LOGISTIC_STEP_SIZE}-{LOGISTIC_STEP_SIZE_RR}.json"

def logistic_point(
  rr: float, 
  xx: float, 
  *, 
  power: int = 1,
  _power: int = 0,
) -> float:
  """Compute the value of the logistic map for some coefficient `rr` and 
  number `xx`.
  """

  _power += 1
  
  xx_next = rr * xx * (1 - xx) 
  if _power == power:
    return xx_next

  return logistic_point(rr, xx_next, power=power, _power=_power)


def _logistic_array(rr: float, xx, *, power = 1):
  """Helper for ``logistic_array``."""

  # NOTE: Numpy multiplies elements stepwise.

  yy, _power = xx, 0
  while _power < power:
    yy = rr * yy * (1 - yy)
    _power = _power + 1

  return yy


def logistic_array(
  rr: float,
  *,
  step: float = 0.001,
  power: int = 1,
):
  """Compute the graph of the logistic map on the closed interval $[0, 1]$."""

  xx = np.arange(0, 1 + step, step=step)
  yy = _logistic_array(rr, xx, power=power)

  return pd.DataFrame(dict(xx=xx, yy=yy))


def logistic_point_sequence(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
) -> Generator[float, None, None]:
  """Iterate the logistic sequence starting at `xx` for coefficient `rr` for
  `iterations` number of steps."""

  yield xx 

  iteration = 0
  while (iteration := iteration + 1) < iterations:
    yield (xx := logistic_point(rr, xx))


def logistic_point_attractor(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept = LOGISTIC_ITERATIONS_KEPT,
) -> List[float]:

  seq = enumerate(logistic_point_sequence(rr, xx,  iterations=iterations)) 
  pos_min = iterations - iterations_kept 
  return [value for pos, value in seq if pos >= pos_min]

```

## Bifurcation Diagram

Below is the bifurcation diagram for the logistic map. A bifurcation diagram
is used to show the regions of attraction for the sequence depending on `rr`.

This graph is generated by iterating over the values of `rr` on the closed 
inverval `[0, 4]` and completing the following process for each `rr`:

1. Generate a random starting point `x0`.
2. Do a large number of iterations.
3. Choose some final number of terminating sequence elements to plot.

A few well known facts about the logistic map are appearent from the figure:

- Below a value of three, the logistic sequence actually converges 
- Above the value of three, the logistic map will tend to converge to cycles.
  That is, the logistic map will be a union of convergent subsequences but is 
  not itself convergent .
- The bifurcation cascade continues as the value of ``rr`` increases.

```{python}
#| fig-cap: Logistic Bifurcation Diagram
#| label: logistic-bifurcation-diagram
def create_bifurcation(
  *,
  start: float = float(2), 
  stop: float = float(4),
  step: float = 0.05,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept: int = LOGISTIC_ITERATIONS_KEPT,
):
  """Returns a ``DataFrame`` containing coefficients, attractors, and initial
  conditions.
  """

  rs = np.arange(start, stop, step)
  x0s =  list( np.random.rand() for _ in range(len(rs)))

  return pd.DataFrame(
    dict(
      rr=rs,
      x0=x0s,
      attractors=list(
        logistic_point_attractor(
          rr, 
          x0,
          iterations=iterations,
          iterations_kept=iterations_kept,
        )
        for rr, x0 in zip(rs, x0s)
      ) 
    )
  )


def load_bifurcation():
  """Load data if it has already been computed. This is especially useful when
  developing this document."""

  if not LOGISTIC_DATA.parent.parent.exists(): 
    os.mkdir(LOGISTIC_DATA.parent.parent)

  if not LOGISTIC_DATA.parent.exists(): 
    os.mkdir(LOGISTIC_DATA.parent)

  if not LOGISTIC_DATA.exists():
    os.mkdir(LOGISTIC_DATA)

  if not LOGISTIC_DATA_BIFURCATION.exists():
    data_raw = create_bifurcation(step=0.0001)

    rr = [rr for rr in data_raw["rr"] for _ in range(LOGISTIC_ITERATIONS_KEPT)] 
    xx =list(itertools.chain(*data_raw["attractors"]) )
    data = pd.DataFrame(dict(rr=rr, xx=xx))
    data.to_csv(LOGISTIC_DATA_BIFURCATION)
  else:
    data = pd.read_csv(LOGISTIC_DATA_BIFURCATION)

  return data

sns.scatterplot(data=load_bifurcation(), x="rr", y="xx", s=0.1)
```

## Logistic Compositions

In this context, **logistic compositions** refers to the sequence of functions

\begin{equation}
  \{\lambda_r^k: k \in N\}
\end{equation}

for some $r$. This sequence exists in the space of continuously differentiable 
functions on the closed unit interval, which is notated as $C^\infty([0, 1])$. 
Here I will not bother to proof that polynomials are continuously 
differentiable as this is easy to find in any analysis book or online.

It is possible to make some nice graphs of the logistic function and its 
composition with itself. The following code is used to generate the subsequent
diagrams:

```{python}
#| label: logistic-composition-4
#| fig-cap: $\lambda_4^k$ for $k \in N$ and $0 < k < 7$. 

def diagram_composition(rr: float, frames: int):
  def update_composition(frame):
    line.set_ydata(data_composition[frame]["yy"])

    tx.set_text(f"k = {frame}")
    return (line,)

  data_composition = [logistic_array(rr, power=k + 1) for k in range(frames)]
  fig, ax = plt.subplots()

  tx = ax.text(0, 1.1, "k = 0")
  line, = ax.plot(
    xx := data_composition[0]["xx"],
    data_composition[0]["yy"],
    color = "blue",
  )
  ax.plot(xx, xx, color="red")
  animation = FuncAnimation(
    fig, 
    update_composition, 
    frames=frames
  )

  plt.close()
  return HTML(animation.to_jshtml())
```

The plot below shows $\lambda_4^k$ *(the compositions)*:

```{python}
diagram_composition(4, frames=7)
```

Seeing the evolutions of the above plot it is clear why the logistic sequence 
does not converge for higher values of ``r``. In the case that ``r`` is ``3`` 
the sequence does converge (as we will see in the next section) and the 
compositions have maxima and minima that are in a smaller range.

```{python}
#| label: logistic-composition-3
#| fig-cap: $\lambda_3^k$ for $k \in N$ and $0 < k < 9$. 
diagram_composition(3, frames=9)
```

Finally, when ``r=2`` the compositions only have ``3`` extrema:

```{python}
#| label: logistic-composition-2
#| fig-cap: $\lambda_2^k$ for $k \in N$ and $0 < k < 11$. 
diagram_composition(1, frames=11)
```



## Cobweb Diagram

A cobweb diagram can be used to visual the covergence of a logistic sequence.
The procedure for creating the diagram is as follows:

1. An initial input ``x0`` is chosen. This can be written as the point 
   ``(x0, x0)`` on the graph.
2. The output ``y0 = logistic_point(x0)`` is computed. This can be written as 
   the point ``(x0, y0)``.
3. The next point will be ``(y0, y0)``, directly on the line defined as
   ``x = y``. This helps find the next input into the logistic map.
4. Since the next input into the logistic map is ``y0``, we follow the ``x``
   projection onto the logistic maps graph to get ``(y0, logistic_point(y0))``.
   This step is realy just the same as step ``2``.

In the most explicit form this is

\begin{multline}
\{ \\
  (x_0, x_0), \\
  (x_0, \lambda_r(x_0)), (\lambda_r(x_0), \lambda(x_0)), \\
  (\lambda(x_0), \lambda^2(x_0)), (\lambda^2(x_0), \lambda^2(x_0))), \\
  (\lambda^2(x_0), \lambda^3(x_0)), (\lambda^3(x_0), \lambda^3(x_0)), \\
  ... \\
  (\lambda^{k-1}(x_0), \lambda^{k}(x_0)), (\lambda^k(x_0), \lambda^k(x_0)), \\
  ...
\}
\end{multline}

Moreover, if $l_r = \{a_k := \lambda^k_r(x_0), k \in N\}$ is a logistic 
sequence, then we are just plotting

\begin{equation}
\{
  (a_0, a_0), (a_0, a_1), (a_1, a_1), (a_1, a_2), (a_2, a_2), ..., 
  (a_k, a_{k+1}), (a_{k+1}, a_{k+1}), ...
\}
\end{equation}

This can be done using the following code:

```{python}
def iter_cobweb(
  rr: float,
  x0: float = LOGISTIC_X0_DEFAULT,
  *, 
  iterations: int = LOGISTIC_ITERATIONS,
):
  iteration, xx = 0, x0
  while (iteration := iteration + 1) < iterations:
    yield (xx, xx)
    yield (xx, xx := logistic_point(rr, xx))


def iter_cobweb_segments(
  rr: float,
  x0: float = LOGISTIC_X0_DEFAULT,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
):
  points = iter_cobweb(rr, x0, iterations=iterations)
  xx, yy = zip(*points) 
  for xx_coords, yy_coords in zip(
      zip(xx[:-1], xx[1:]),
      zip(yy[:-1], yy[1:])
  ):
    yield (xx_coords, yy_coords)


def diagram_cobweb(
  rr: float, 
  x0: float = LOGISTIC_X0_DEFAULT, 
  *, 
  frames: int,
  interval: int = 200,
):
  def update_cobweb(frame):
    line, = ax.plot(
      data_cobweb[frame][0],
      data_cobweb[frame][1],
      color="red",
    )
    return line


  data_logistic = logistic_array(rr)
  data_cobweb = list(iter_cobweb_segments(rr, x0, iterations=frames))

  plt.xlim(0, 1)
  plt.ylim(0, 1)
  fig, ax = plt.subplots()

  # Plot the logistic map.
  ax.plot(
    xx := data_logistic["xx"],
    data_logistic["yy"],
    color = "blue",
  )
  ax.plot(xx, xx, color="green")

  # Animate cobweb.
  animation = FuncAnimation(
    fig, 
    update_cobweb, 
    frames=frames,
    interval=interval
  )

  # Why do I have to do this twice?
  plt.close()
  plt.close()
  return HTML(animation.to_jshtml())
```

Starting with a large value we can see that sequence probably does not 
converge:

```{python}
#| label: fig-logistic-cobweb-3-8
#| fig-cap: "Logistic Cobweb Diagram for $r = 3.8$."
diagram_cobweb(3.8, frames=200, interval=50)
```

With a smaller value of ``r`` the convergence easy to confirm visually:

```{python}
#| label: fig-logistic-cobweb-2
#| fig-cap: "Logistic Cobweb Diagram for $r = 3$."

diagram_cobweb(2, frames=15)
```

The following code can be used to animate the sequence starting at the same 
point:

```{python}
def load_cobweb_rr(x0):
  if LOGISTIC_DATA_COBWEB_RR.exists():
    with open(LOGISTIC_DATA_COBWEB_RR, "r") as file:
      raw = json.load(file)

    return {
      float(rr): df_raw
      for rr, df_raw in     raw["data_cobweb"].items()
    }, {
      float(rr): pd.DataFrame(json.loads(df_raw))
      for rr, df_raw in raw["data_logistic"].items()
    }

  rrs = np.arange(0, 4, LOGISTIC_STEP_SIZE_RR)
  data_cobweb = {
    rr: list(zip(*iter_cobweb(rr, x0, iterations=len(rrs))))
    for rr in rrs
  }
  data_logistic = {
    rr: logistic_array(rr)
    for rr in rrs
  }

  with open(LOGISTIC_DATA_COBWEB_RR, "w") as file:
    json.dump(
      {
        "data_cobweb": data_cobweb,
        "data_logistic": {
          rr: df.to_json() 
          for rr, df in data_logistic.items()
        }
      }, 
      file
    )

  return (data_cobweb, data_logistic)


def diagram_cobweb_rr(interval: int = 200):
  x0 = LOGISTIC_X0_DEFAULT
  data_cobweb, data_logistic = load_cobweb_rr(x0)

  fig, ax = plt.subplots()

  rrs = np.array(sorted(data_cobweb))
  rr0 = min(rrs)


  line_cobweb, = ax.plot(
    data_cobweb[rr0][0],
    data_cobweb[rr0][1],
    color="blue",
  )
  line_logistic, = ax.plot(
    data_logistic[rr0]["xx"],
    data_logistic[rr0]["yy"],
    color="red",
  )
  ax.plot(xx := data_logistic[rr0]["xx"], xx, color="green")
  tx = ax.text(0, 1.1, f"r = {rr0}")

  def update_cobweb_rr(frame_rr):
    line_cobweb.set_xdata(data_cobweb[frame_rr][0])
    line_cobweb.set_ydata(data_cobweb[frame_rr][1])

    line_logistic.set_xdata(data_logistic[frame_rr]["xx"])
    line_logistic.set_ydata(data_logistic[frame_rr]["yy"])

    tx.set_text(f"r = {round(frame_rr, 2)}")

    return (line_cobweb, line_logistic)

  animation = FuncAnimation(
    fig,
    update_cobweb_rr,
    frames=rrs,
    interval=interval,
  )
  plt.close()
  return HTML(animation.to_jshtml())
```

The animation below shows cobweb diagrams with varying values of ``rr``.

```{python}
#| label: fig-logistic-cobweb-rr
#| fig-cap: "Use the slider to change $r$."

diagram_cobweb_rr(interval=100)
```
