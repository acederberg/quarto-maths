---
server: shiny
title: "The Logistic Map and Chaos"
format:
  html:
    code-fold: false
execute:
  cache: true
---


## Definitions

Below is the definition of the logistic map:

```{python}
#| echo: true
import itertools
import os
import pathlib
from os import environ
from typing import Generator, List

import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt



LOGISTIC_STEP_SIZE = float(environ.get("LOGISTIC_STEP_SIZE", "0.05"))
LOGISTIC_ITERATIONS = int(environ.get("LOGISTIC_ITERATIONS", "1000 "))
LOGISTIC_ITERATIONS_KEPT = int(environ.get("LOGISTIC_ITERATIONS_KEPT", "100"))

QUARTO_POSTS = pathlib.Path(".").resolve()
LOGISTIC_DATA = QUARTO_POSTS.parent / "demo-data" / "posts" / "logistic_data"
LOGISTIC_DATA_BIFURCATION = LOGISTIC_DATA / f"logistic-bifurcation-{LOGISTIC_ITERATIONS}-{LOGISTIC_STEP_SIZE}.csv"


def logistic_point(rr: float, xx: float) -> float:
  """Compute the value of the logistic map for some coefficient `rr` and 
  number `xx`.
  """
  return rr * xx * (1 - xx) 


def logistic_array(rr: float, *, step: float = 0.001):
  """Compute the graph of the logistic map on the closed interval $[0, 1]$."""

  # NOTE: Numpy multiplies elements stepwise.
  xx = np.arange(0, 1 + step, step=step)
  yy = rr * xx * (1 - xx)

  return pd.DataFrame(dict(xx=xx, yy=yy))


def logistic_point_sequence(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
) -> Generator[float, None, None]:
  """Iterate the logistic sequence starting at `xx` for coefficient `rr` for
  `iterations` number of steps."""

  yield xx 

  iteration = 0
  while (iteration := iteration + 1) < iterations:
    yield (xx := logistic_point(rr, xx))


def logistic_point_attractor(
  rr: float,
  xx: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept = LOGISTIC_ITERATIONS_KEPT,
) -> List[float]:

  seq = enumerate(logistic_point_sequence(rr, xx,  iterations=iterations)) 
  pos_min = iterations - iterations_kept 
  return [value for pos, value in seq if pos >= pos_min]


```


## Bifurcation Diagram

Below is the bifurcation diagram for the logistic map. A bifurcation diagram
is used to show the regions of attraction for the series depending on `rr`.

This graph is generated by iterating over the values of `rr` on the closed 
inverval `[0, 4]` and completing the following process for each `rr`:

1. Generate a random starting point `x0`.
2. Do some large number of iterations.
3. Choose some final number of terminating sequence members to plot.

A few well known facts about the logistic map are appearent from the figure:

- Below a value of three, the logistic map has a stable convergence point. 
- Above the value of three, the logistic map will tend to converge to cycles,
  that is, the logistic map will have convergent subsequences but is not 
  convergent itself.
- The bifurcation cascade continues as the value of ``rr`` increases.

```{python}
def logistic_bifurcation_data(
  *,
  start: float = float(2), 
  stop: float = float(4),
  step: float = 0.05,
  iterations: int = LOGISTIC_ITERATIONS,
  iterations_kept: int = LOGISTIC_ITERATIONS_KEPT,
):
  """Returns a ``DataFrame`` containing coefficients, attractors, and initial
  conditions.
  """

  rs = np.arange(start, stop, step)
  x0s =  list( np.random.rand() for _ in range(len(rs)))

  return pd.DataFrame(
    dict(
      rr=rs,
      x0=x0s,
      attractors=list(
        logistic_point_attractor(
          rr, 
          x0,
          iterations=iterations,
          iterations_kept=iterations_kept,
        )
        for rr, x0 in zip(rs, x0s)
      ) 
    )
  )


if not LOGISTIC_DATA.exists():
  os.mkdir(LOGISTIC_DATA)

if not LOGISTIC_DATA_BIFURCATION.exists():
  data_raw = logistic_bifurcation_data(step=0.0001)

  rr = [rr for rr in data_raw["rr"] for _ in range(LOGISTIC_ITERATIONS_KEPT)] 
  xx =list(itertools.chain(*data_raw["attractors"]) )
  data = pd.DataFrame(dict(rr=rr, xx=xx))
  data.to_csv(LOGISTIC_DATA_BIFURCATION)
else:
  data = pd.read_csv(LOGISTIC_DATA_BIFURCATION)
```

```{python}
#| label: fig-logistic-bifurcation
#| fig-cap: "Logistic Bifurcation"

sns.scatterplot(data=data, x="rr", y="xx", s=0.1)
```


## Cobweb Diagram

A cobweb diagram can be used to demonstrate how the sequence definition results
in chaos. 

1. An initial input ``x0`` is chosen. This can be written as the point 
   ``(x0, 0)`` on the graph.
2. The output ``y0 = logistic_point(x0)`` is computed. This can be written as 
   the point ``(x0, y0)``.
3. The next point will be ``(y0, y0)``, directly on the line defined as
   ``x = y``. This helps find the next input into the logistic map.
4. Since the next input into the logistic map is ``y0``, we follow the ``x``
   projection onto the logistic maps graph to get ``(y0, logistic_point(y0))``.
   This step is realy just the same as step ``2``.

Cobweb diagram:


### {.sidebar}

```{python}
from shiny.express import render, ui

x0 = ui.input_numeric("x0", "Initial Value", 0.7,  min=0, max=1)
rr = ui.input_numeric("rr", "Coefficient", 3.8, min=0, max=4)
```


### Column

```{python}
def logistic_cobweb_sequence(
  rr: float,
  x0: float,
  *, 
  iterations: int = LOGISTIC_ITERATIONS,
):
  iteration = 0 

  yield (xx := x0, 0) # 1
  while (iteration := iteration + 1) < iterations:
    yield (xx, yy := logistic_point(rr, xx)) # 2
    yield (xx := yy, yy) # 3


def logistic_cobweb(
  rr: float,
  x0: float,
  *,
  iterations: int = LOGISTIC_ITERATIONS,
):
  points = logistic_cobweb_sequence(rr, x0, iterations=iterations)
  xx, yy = zip(*points) 
  for xx_coords, yy_coords in zip(
      zip(xx[:-1], xx[1:]),
      zip(yy[:-1], yy[1:])
  ):
    yield pd.DataFrame(dict(xx=xx_coords, yy=yy_coords))


@render.plot
def cobweb():
  #| label: fig-logistic-cobweb
  #| fig-cap: "Logistic Cobweb Diagram."

  assert False
  rr = input.rr() # type: ignore
  x0 = input.x0() # type: ignore

  data = logistic_array(rr)
  sns.lineplot(data=data, x="xx", y="yy")
  sns.lineplot(data=data, x="xx", y="xx")

  for line in logistic_cobweb(rr, x0, iterations=100):
    sns.lineplot(data=pd.DataFrame(line), x="xx", y="yy")

  plt.xlim(0, 1)
  plt.ylim(0, 1)
```



